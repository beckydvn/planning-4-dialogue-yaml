---
version: "3.1"
name: order-pizza

# this is what would be sent to rasa
nlu:
  - regex: card_number
    examples: |
      - \d{16}

  - lookup: order
    examples: |
      - cheese
      - pepperoni
      - mushroom
      - gluten free
      - hawaiian

  - intent: greet
    examples: |
      - Hey
      - Hi
      - hey there

  - intent: leave
    examples: |
      - Goodbye
      - Bye
      - That's all

  - intent: share_order
    examples: |
      - I want a [cheese](order) pizza
      - [pepperoni](order) pizza please!
      - Do you have [mushroom](order) pizza?

  - intent: share_location
    examples: |
      - I live in [New York City](location).
      - Do you deliver to [Denver](location)?
      - I want my pizza to be delivered to [Chicago](location).

  - intent: share_payment_method
    examples: |
      - I want to pay by [credit card](payment_method).
      - Can I pay with [debit](payment_method)?
      - I will pay in [cash](payment_method)

  - intent: pay
    examples: |
      - My credit card number is [0123456789012342](card_number).
      - This is my account number [3637456789573835](card_number)
      - Ok, the number on my card is [0586456789456048](card_number).
    
# entities to extract from the user
# TODO: should have types
context-variables:
  - user_initiative
    
  - order
  - location
  - payment_method
  - card_number
  - goal

# fluents are not entities but are used purely for dialogue flow
# this should not be a separate section but instead should be indicated by flags
# within actions
fluents:
  - started # created by default
  - goal # created by default
  - user_initiative # created by default

# effects:
#   - 

# each action that the agent can perform is composed of:
#   a category (optional). this allows for setting restrictions on categories
#       of actions later
#   condition. these have to occur before the action occurs.
#       options:
#           have (bot has extracted this entity already)
#           maybe_have (bot may have this entity, but needs to clarify)
#   effects. what the action will do.
#       options:
#           add (set a fluent to true)
#           del (set a fluent to false)
#           rule out actions (rule out actions from occurring after this one)
#               can use for:
#                   list of actions
#                   category of actions
#                   exclude all but, followed by a list of actions
#           forced follow-up

actions:
  # OUTCOMES -- should be able to specify "ask for this" and we should assume
  # that the bot must have initiative to take that action. otherwise, they're
  # going to have to specify every time and it's going to get tiresome.
  # setting initiative manually should also be as easy as setting a value to true
  # or false because it's going to happen every action.

  # ask-for actions assume:
  #   conditions:
  #   - that the agent either does not have or is not sure of a context variable
  #     that it needs to extract from the user
  #   - the agent has initiative in order to execute.
  ask-for:
    # ask for the user's location
    - name: ask-location
      # categories can hold across action "types"
      category: get_info
      # link to the entity to slot fill, in this case order
      # we assume that to perform any "ask-for" action, the bot must have
      # initiative, i.e. (not (user_initiative)). added during parsing
      entities:
        - location
      # note that, for "ask-for" types of actions: we automatically add 
      # and(not(have_{entity} ), not(maybe_have_{entity} ) )
      # to the precondition when parsing. this allows bot designers to focus on
      # specifying any non-default preconditions instead of specifying obvious patterns
      # every time.
      dialogue:
        ask-dialogue: "Where are you located?"
        clarify-dialogue: "Are you located in {location}?"
      
      effects:
        # can be and or one-of
        - one-of:
          # descriptors: have, not, maybe
          - have: location
          - forced-follow-up: ask-location
        # can be and or one-of
        - one-of:
          # descriptors: have, not, maybe
          - have: test1
        - test3

      

      

  #   # ask for the user's order
  #   order:
  #     category: get_info
  #     entity: order

  #   payment_method:
  #     category: get_info
  #     entity: 


  # - custom:


      
  # # check if what the user requested is available
  # - check_order_availability
  #   category: get_info
  #   need:
  #     have:
  #       - order
      


  #   effects:
  # # check if the restaurant is currently delivering to that city
  # - check_city_delivery
  # - process_payment
  # # place order if the payment goes through
  # - place_order

...